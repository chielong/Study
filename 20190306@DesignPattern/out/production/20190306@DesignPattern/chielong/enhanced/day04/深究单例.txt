@Author:chielong

=====================================
Q:单例模式的双重检查锁为什么要做两次非空检测？
    思路：双重检查锁各个语句的意义
    if(null = obj) {                // 1
        synchronized(...) {         // 2
            if(null == obj) {       // 3
                obj = new Obj();
            }
        }
    }
    return obj;
    这是一个新服开服首次通关的游戏。假设obj是需要单例的对象（需要被首通的副本）。
    在[1]处，首先判断obj是否已经被初始化。如果已经被初始化，当然不再new一份新的!这种情况下，就是新服开服了好几天，已经被通关了。
    但是因为在有很多的玩家（多线程情况）在没开服之前就蹲着，一开服就顺利进入了游戏，这是他们是具有首通资格的！
    为了保证系统正确性，副本设定了只能排队进副本。
    假设这一瞬间，队伍已经排好了，顺序是：尖沙咀段坤、蟑螂恶霸、蝎子莱莱...
    这时候，尖沙咀段坤当然第一个进副本。
    如果没有[3]处的判断，则会：
        尖沙咀段坤通关。蟑螂恶霸通关。蝎子莱莱通关....
        段坤：？？？(黑人问号脸)
    但是有了[3]处判断，就是：
        尖沙咀段坤通关。由于obj已经被实例化，蟑螂恶霸失去资格，蝎子莱莱失去资格...
        段坤：YES!耶稣留住我了。

Q:单例模式双重检查锁中的synchronized为什么锁住的是class，可以是int或者object吗？
    其实synchronized无所谓锁的是什么。最重要的一点就是：尽量保证锁是单例的。
    这种回答看起来是一个鸡生蛋，蛋生鸡的问题。其实并不是。
    因为我们可以很容易的得到一个单例的锁。比如：
    Class对象(任何类.class)。
    从这个类对象，我们就可以拓展出我们的视野：比如静态变量（jvm中静态变量和非静态变量存在不同的地方，静态变量永远是独一份的！）。
    再比如：当前类加载器。
    再比如：任意一个字符串。(jvm，字符串常量池)
    甚至是：我们可以传进去一把锁。（以后永远不要换锁，永远保持这个参数。因为）。
    那么可以是object吗？可以，如果这个object是静态就可以。